# 动态规划-背包

## 01背包问题

每个物体只有两种状态：“取”或者“不取”。

能用动态规划解决的问题，采用回溯法解决可能会有很大的时间复杂度，这里01背包问题可能就是\`O\(2^n\)\`的时间复杂度，指数级别的时间复杂度。

> 对于背包问题，有一种写法， 是使用二维数组，即`dp[i][j]` **表示从下标为`[0-i]`的物品里任意取，放进容量为 j 的背包，价值总和最大是多少**。

> 根据数组定义的含义可以有两个方向推出来dp\[i\]\[j\]，
>
> * **不放物品i**：由dp\[i - 1\]\[j\]推出，即背包容量为j，里面不放物品i的最大价值，此时dp\[i\]\[j\]就是dp\[i - 1\]\[j\]。\(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。\)
> * **放物品i**：由dp\[i - 1\]\[j - weight\[i\]\]推出，dp\[i - 1\]\[j - weight\[i\]\] 为背包容量为j - weight\[i\]的时候不放物品i的最大价值，那么dp\[i - 1\]\[j - weight\[i\]\] + value\[i\] （物品i的价值），就是背包放物品i得到的最大价值
>
> 所以递归公式： dp\[i\]\[j\] = max\(dp\[i - 1\]\[j\], dp\[i - 1\]\[j - weight\[i\]\] + value\[i\]\);

## 01背包问题 --- 滚动数组

二维 dp 数组降为 一维 dp 数组 --- 滚动数组

> 对于背包问题其实状态都是可以压缩的。
>
> 在使用二维数组的时候，递推公式：dp\[i\]\[j\] = max\(dp\[i - 1\]\[j\], dp\[i - 1\]\[j - weight\[i\]\] + value\[i\]\);
>
> **其实可以发现如果把dp\[i - 1\]那一层拷贝到dp\[i\]上，表达式完全可以是：dp\[i\]\[j\] = max\(dp\[i\]\[j\], dp\[i\]\[j - weight\[i\]\] + value\[i\]\);**
>
> **与其把dp\[i - 1\]这一层拷贝到dp\[i\]上，不如只用一个一维数组了**，只用dp\[j\]（一维数组，也可以理解是一个滚动数组）。
>
> 这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。
>
> 读到这里估计大家都忘了 dp\[i\]\[j\]里的i和j表达的是什么了，i是物品，j是背包容量。
>
> **dp\[i\]\[j\] 表示从下标为\[0-i\]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

> 内层倒叙遍历 --- 必须外层是物品，内层遍历是背包容量。

```cpp
void test_1_wei_bag_problem() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

int main() {
    test_1_wei_bag_problem();
}
```







